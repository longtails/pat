/*
 * 2017.3.4甲级考试
 * 心得：考试的时候，考蒙了！考场换跟自己平常练习的环境差别太大了,
 * 平时的环境：ubuntu16.06,vim,g++
 * 考场环境：xp,vs2008,不知到怎么回事，居然不能复制粘贴测试用例到cmd上，
 * 害的我一个一个敲进入的。
 * A题就整整花了半个小时！我想其中有十分中就是浪费在环境不熟悉上，测试用例不能
 * 复制粘贴！第一用例就很乱！不过半个小时对用例通过后，提交一次AC!
 * B题提交了两次，第一次得了8分，我只是对他进行了一下排序，拿出两个最大值
 * 计算。后来看了看C和D题。回想自己答得太简单，肯定不对，重新读题，原来
 * 理解有问题，改变想法后测试用例满足后，在原来基础上加了个循环，找最大值
 * AC了！
 * C题就是这道题了其实，这20分还是捡回来的，第一遍读题就没太懂！先做D题，
 * 还剩半个小时，这时已经不报希望了！因为这时已经有75分了！索性就按照
 * 题目所说，就当碰分！记录节点的度数，根据奇度数节点的个数：0欧拉路径，
 * 2欧拉回路，其他非欧拉！---->结果又拿了20分！又读题，说是两个奇数节点，
 * 必须一个起点一个终点，最后就在这个条件上等到了考试结束！
 * D题BC题难住了！索性翻看一下D,结果发现这道题，考什么很清楚！就是LNR LRN
 * 确定一个树，然后层序遍历，之字形输出。LNR LRN寒假就刷过一部分大概怎么处理
 * 还是知道的--也坑在这--只是大概知道--结果花费了将近一个半小时，代码框架写完
 * 也才不到十分钟，剩下的时间就在调试创建树时的错误！再说层序遍历，刚好前两天
 * 学习了层序遍历算法及层信息的输出！靠前还复习了一遍！索性就先答这30分的题目。
 * ---历经debug，最后剩半小时，测试用例正确了，提交代码一次AC!
 *
 *  今天看查了一下这道题，别人说这个图联通不连通要判断，一下子就明白了！
 *  写了个un getf,循环检查父亲是不是一个！就AC了!
 *  ---------------------------------------------------------------------
 *总体来说，刷了PAT甲级题库一半后，感觉这次的题目并不难！
 *答的困难，主要有一下原因：
 *	1.考试环境的不熟悉！这就浪费了半个小时！
 *	2.平常只是刷题了，并不是很好的掌握，最后一道题就花费了一个半小时！
 *	3.英语阅读能力有待很大的提高，在B和C题上话费时间较多！
 *	4.所学的数据结构和离散图论都给忘了！在C题！也是平常不注意，一个联通问题，
 *	没了五分！
 *	----------------------------------------------------------------------
 *	再接再厉吧！
 *							2017.3.4
 * */
#include<iostream>
using namespace std;
int N;
int M;
int data[510][510];
int d[510];
int f[510];
int getF(int a)
{
	if(a==f[a])
	  return a;
	else
	  f[a]=getF(f[a]);
}
void un(int a,int b)
{
	int af=getF(a);
	int bf=getF(b);
	if(af>bf)f[af]=bf;
	else f[bf]=af;
}
int main()
{
	cin>>N>>M;
	int tmp_a;
	int tmp_b;
	for(int i=0;i<N;i++)
	{
		d[i]=0;
		f[i]=i;
		for(int j=0;j<N;j++)
		{
			data[i][j]=0;
		}
	}
	for(int i=0;i<M;i++)
	{
		cin>>tmp_a>>tmp_b;
		//set 0~n-1
		tmp_a--;
		tmp_b--;
		data[tmp_a][tmp_b]=1;
		data[tmp_b][tmp_a]=1;
		d[tmp_a]++;
		d[tmp_b]++;
		un(tmp_a,tmp_b);
	}
	int count=0;
	for(int i=0;i<N;i++)
	{
		cout<<d[i];
		if(d[i]%2==1)
		  count++;
		if(i==N-1)
		  cout<<endl;
		else
		  cout<<" ";
	}
	bool isUn=true;
	for(int i=0;i<N;i++)
	{
		if(f[0]!=f[i])
		  isUn=false;
	}
	if(count==2&&isUn)
	  cout<<"Semi-Eulerian"<<endl;
	else if(count==0&&isUn)
	  cout<<"Eulerian"<<endl;
	else
	  cout<<"Non-Eulerian"<<endl;
	return 0;
}
